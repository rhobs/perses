{"version":3,"sources":["../../../../src/plugins/prometheus-time-series-query/get-time-series-data.ts"],"sourcesContent":["// Copyright 2025 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  DatasourceSpec,\n  DurationString,\n  Notice,\n  parseDurationString,\n  TimeSeries,\n  TimeSeriesData,\n} from '@perses-dev/core';\nimport { TimeSeriesQueryPlugin, datasourceSelectValueToSelector, replaceVariables } from '@perses-dev/plugin-system';\nimport { fromUnixTime, milliseconds } from 'date-fns';\nimport {\n  parseValueTuple,\n  PrometheusClient,\n  getDurationStringSeconds,\n  getPrometheusTimeRange,\n  getRangeStep,\n  DEFAULT_PROM,\n  MatrixData,\n  VectorData,\n  ScalarData,\n  InstantQueryResultType,\n  PROM_DATASOURCE_KIND,\n} from '../../model';\nimport { getFormattedPrometheusSeriesName } from '../../utils';\nimport { DEFAULT_SCRAPE_INTERVAL, PrometheusDatasourceSpec } from '../types';\nimport { PrometheusTimeSeriesQuerySpec } from './time-series-query-model';\nimport { replacePromBuiltinVariables } from './replace-prom-builtin-variables';\n\nexport const getTimeSeriesData: TimeSeriesQueryPlugin<PrometheusTimeSeriesQuerySpec>['getTimeSeriesData'] = async (\n  spec,\n  context,\n  abortSignal\n) => {\n  if (spec.query === undefined || spec.query === null || spec.query === '') {\n    // Do not make a request to the backend, instead return an empty TimeSeriesData\n    return { series: [] };\n  }\n\n  const listDatasourceSelectItems = await context.datasourceStore.listDatasourceSelectItems(PROM_DATASOURCE_KIND);\n\n  const selectedDatasource =\n    datasourceSelectValueToSelector(\n      spec.datasource ?? DEFAULT_PROM,\n      context.variableState,\n      listDatasourceSelectItems\n    ) ?? DEFAULT_PROM;\n\n  const datasource = (await context.datasourceStore.getDatasource(\n    selectedDatasource\n  )) as DatasourceSpec<PrometheusDatasourceSpec>;\n  const datasourceScrapeInterval = Math.trunc(\n    milliseconds(parseDurationString(datasource.plugin.spec.scrapeInterval ?? DEFAULT_SCRAPE_INTERVAL)) / 1000\n  );\n\n  // Min step is the lower bound of the interval between data points\n  // If no value is provided for it, it should default to the scrape interval of the datasource\n  const minStep =\n    getDurationStringSeconds(\n      // resolve any variable that may have been provided\n      // TODO add a validation check to make sure the variable is a DurationString, to avoid the back & forth cast here\n      replaceVariables(spec.minStep as string, context.variableState) as DurationString\n    ) ?? datasourceScrapeInterval;\n\n  const timeRange = getPrometheusTimeRange(context.timeRange);\n  const step = getRangeStep(timeRange, minStep, undefined, context.suggestedStepMs); // TODO: resolution\n\n  // Align the time range so that it's a multiple of the step\n  let { start, end } = timeRange;\n\n  const utcOffsetSec = new Date().getTimezoneOffset() * 60;\n\n  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;\n  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;\n  start = alignedStart;\n  end = alignedEnd;\n\n  /* Ensure end is always greater than start:\n     If the step is greater than equal to the diff of end and start,\n     both start, and end will eventually be rounded to the same value,\n     Consequently, the time range will be zero, which does not return any valid value\n  */\n  if (end === start) {\n    end = start + step;\n    console.warn(`Step (${step}) was larger than the time range! end of time range was set accordingly.`);\n  }\n\n  // Replace variable placeholders in PromQL query\n  const intervalMs = step * 1000;\n  const minStepMs = minStep * 1000;\n\n  let query = replacePromBuiltinVariables(spec.query, minStepMs, intervalMs);\n  query = replaceVariables(query, context.variableState);\n\n  let seriesNameFormat = spec.seriesNameFormat;\n  // if series name format is defined, replace variable placeholders in series name format\n  if (seriesNameFormat) {\n    seriesNameFormat = replaceVariables(seriesNameFormat, context.variableState);\n  }\n\n  // Get the datasource, using the default Prom Datasource if one isn't specified in the query\n  const client: PrometheusClient = await context.datasourceStore.getDatasourceClient(selectedDatasource);\n\n  // Make the request to Prom\n\n  let response;\n  switch (context.mode) {\n    case 'instant':\n      response = await client.instantQuery(\n        {\n          query,\n          time: end,\n        },\n        undefined,\n        abortSignal\n      );\n      break;\n    case 'range':\n    default:\n      response = await client.rangeQuery(\n        {\n          query,\n          start,\n          end,\n          step,\n        },\n        undefined,\n        abortSignal\n      );\n      break;\n  }\n\n  // TODO: What about error responses from Prom that have a response body?\n  const result = response.data;\n\n  // Custom display for response header warnings, configurable error responses display coming next\n  const notices: Notice[] = [];\n  if (response.status === 'success') {\n    const warnings = response.warnings ?? [];\n    const warningMessage = warnings[0] ?? '';\n    if (warningMessage !== '') {\n      notices.push({\n        type: 'warning',\n        message: warningMessage,\n      });\n    }\n  }\n\n  // Transform response\n  const chartData: TimeSeriesData = {\n    // Return the time range and step we actually used for the query\n    timeRange: { start: fromUnixTime(start), end: fromUnixTime(end) },\n    stepMs: step * 1000,\n\n    series: buildTimeSeries(query, result, seriesNameFormat),\n    metadata: {\n      notices,\n      executedQueryString: query,\n    },\n  };\n\n  return chartData;\n};\n\nfunction buildVectorData(query: string, data: VectorData, seriesNameFormat: string | undefined): TimeSeries[] {\n  return data.result.map((res) => {\n    const { metric, value, histogram } = res;\n\n    // Account for seriesNameFormat from query editor when determining name to show in legend, tooltip, etc.\n    const { name, formattedName } = getFormattedPrometheusSeriesName(query, metric, seriesNameFormat);\n\n    if (histogram) {\n      return {\n        name,\n        formattedName,\n        labels: metric,\n        values: [parseValueTuple([histogram[0], histogram[1].sum])],\n        histograms: [histogram],\n      };\n    }\n\n    return {\n      name,\n      formattedName,\n      labels: metric,\n      values: [parseValueTuple(value)],\n    };\n  });\n}\n\nfunction buildMatrixData(query: string, data: MatrixData, seriesNameFormat: string | undefined): TimeSeries[] {\n  return data.result.map((res) => {\n    const { metric, values, histograms } = res;\n\n    // Account for seriesNameFormat from query editor when determining name to show in legend, tooltip, etc.\n    const { name, formattedName } = getFormattedPrometheusSeriesName(query, metric, seriesNameFormat);\n\n    if (histograms) {\n      return {\n        name,\n        formattedName,\n        labels: metric,\n        values: histograms.map((histogram) => parseValueTuple([histogram[0], histogram[1].sum])),\n        histograms: histograms.map((histogram) => histogram),\n      };\n    }\n\n    return {\n      name,\n      formattedName,\n      labels: metric,\n      values: values.map(parseValueTuple),\n    };\n  });\n}\n\nfunction buildScalarData(query: string, data: ScalarData, seriesNameFormat: string | undefined): TimeSeries[] {\n  const { name, formattedName } = getFormattedPrometheusSeriesName(query, {}, seriesNameFormat);\n  return [\n    {\n      name,\n      values: [parseValueTuple(data.result)],\n      formattedName,\n    },\n  ];\n}\n\nfunction buildTimeSeries(query: string, data?: InstantQueryResultType, seriesNameFormat?: string): TimeSeries[] {\n  if (!data) {\n    return [];\n  }\n\n  const resultType = data.resultType;\n  switch (resultType) {\n    case 'vector':\n      return buildVectorData(query, data, seriesNameFormat);\n    case 'matrix':\n      return buildMatrixData(query, data, seriesNameFormat);\n    case 'scalar':\n      return buildScalarData(query, data, seriesNameFormat);\n    default:\n      console.warn('Unknown result type', resultType, data);\n      return [];\n  }\n}\n"],"names":["parseDurationString","datasourceSelectValueToSelector","replaceVariables","fromUnixTime","milliseconds","parseValueTuple","getDurationStringSeconds","getPrometheusTimeRange","getRangeStep","DEFAULT_PROM","PROM_DATASOURCE_KIND","getFormattedPrometheusSeriesName","DEFAULT_SCRAPE_INTERVAL","replacePromBuiltinVariables","getTimeSeriesData","spec","context","abortSignal","query","undefined","series","listDatasourceSelectItems","datasourceStore","selectedDatasource","datasource","variableState","getDatasource","datasourceScrapeInterval","Math","trunc","plugin","scrapeInterval","minStep","timeRange","step","suggestedStepMs","start","end","utcOffsetSec","Date","getTimezoneOffset","alignedEnd","floor","alignedStart","console","warn","intervalMs","minStepMs","seriesNameFormat","client","getDatasourceClient","response","mode","instantQuery","time","rangeQuery","result","data","notices","status","warnings","warningMessage","push","type","message","chartData","stepMs","buildTimeSeries","metadata","executedQueryString","buildVectorData","map","res","metric","value","histogram","name","formattedName","labels","values","sum","histograms","buildMatrixData","buildScalarData","resultType"],"mappings":"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"}