{"version":3,"sources":["../../../src/model/prometheus-client.ts"],"sourcesContent":["// Copyright 2023 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { fetch, fetchJson, RequestHeaders } from '@perses-dev/core';\nimport { DatasourceClient } from '@perses-dev/plugin-system';\nimport {\n  InstantQueryRequestParameters,\n  InstantQueryResponse,\n  LabelNamesRequestParameters,\n  LabelNamesResponse,\n  LabelValuesRequestParameters,\n  LabelValuesResponse,\n  MetricMetadataRequestParameters,\n  MetricMetadataResponse,\n  ParseQueryRequestParameters,\n  ParseQueryResponse,\n  RangeQueryRequestParameters,\n  RangeQueryResponse,\n  SeriesRequestParameters,\n  SeriesResponse,\n  SuccessResponse,\n} from './api-types';\n\ninterface PrometheusClientOptions {\n  datasourceUrl: string;\n  headers?: RequestHeaders;\n}\n\nexport interface PrometheusClient extends DatasourceClient {\n  options: PrometheusClientOptions;\n  instantQuery(\n    params: InstantQueryRequestParameters,\n    headers?: RequestHeaders,\n    signal?: AbortSignal\n  ): Promise<InstantQueryResponse>;\n  rangeQuery(\n    params: RangeQueryRequestParameters,\n    headers?: RequestHeaders,\n    signal?: AbortSignal\n  ): Promise<RangeQueryResponse>;\n  labelNames(\n    params: LabelNamesRequestParameters,\n    headers?: RequestHeaders,\n    signal?: AbortSignal\n  ): Promise<LabelNamesResponse>;\n  labelValues(\n    params: LabelValuesRequestParameters,\n    headers?: RequestHeaders,\n    signal?: AbortSignal\n  ): Promise<LabelValuesResponse>;\n  metricMetadata(\n    params: MetricMetadataRequestParameters,\n    headers?: RequestHeaders,\n    signal?: AbortSignal\n  ): Promise<MetricMetadataResponse>;\n  series(params: SeriesRequestParameters, headers?: RequestHeaders, signal?: AbortSignal): Promise<SeriesResponse>;\n  parseQuery(\n    params: ParseQueryRequestParameters,\n    headers?: RequestHeaders,\n    signal?: AbortSignal\n  ): Promise<ParseQueryResponse>;\n}\n\nexport interface QueryOptions {\n  datasourceUrl: string;\n  headers?: RequestHeaders;\n  abortSignal?: AbortSignal;\n  queryParams?: Record<string, string>;\n}\n\n/**\n * Builds a query string from datasource-level query parameters.\n * Optionally merges with existing URLSearchParams.\n * Returns empty string if no parameters, otherwise returns query string with leading '?'.\n */\nfunction buildQueryString(queryParams?: Record<string, string>, initialParams?: URLSearchParams): string {\n  const urlParams = initialParams || new URLSearchParams();\n\n  if (queryParams) {\n    Object.entries(queryParams).forEach(([key, value]) => {\n      urlParams.set(key, value);\n    });\n  }\n\n  const queryString = urlParams.toString();\n  return queryString !== '' ? `?${queryString}` : '';\n}\n\n/**\n * Calls the `/-/healthy` endpoint to check if the datasource is healthy.\n */\nexport function healthCheck(queryOptions: QueryOptions) {\n  return async (): Promise<boolean> => {\n    const url = `${queryOptions.datasourceUrl}/-/healthy${buildQueryString(queryOptions.queryParams)}`;\n\n    try {\n      const resp = await fetch(url, { headers: queryOptions.headers, signal: queryOptions.abortSignal });\n      return resp.status === 200;\n    } catch {\n      return false;\n    }\n  };\n}\n\n/**\n * Calls the `/api/v1/query` endpoint to get metrics data.\n */\nexport function instantQuery(\n  params: InstantQueryRequestParameters,\n  queryOptions: QueryOptions\n): Promise<InstantQueryResponse> {\n  return fetchWithPost<InstantQueryRequestParameters, InstantQueryResponse>('/api/v1/query', params, queryOptions);\n}\n\n/**\n * Calls the `/api/v1/query_range` endpoint to get metrics data.\n */\nexport function rangeQuery(\n  params: RangeQueryRequestParameters,\n  queryOptions: QueryOptions\n): Promise<RangeQueryResponse> {\n  return fetchWithPost<RangeQueryRequestParameters, RangeQueryResponse>('/api/v1/query_range', params, queryOptions);\n}\n\n/**\n * Calls the `/api/v1/labels` endpoint to get a list of label names.\n */\nexport function labelNames(\n  params: LabelNamesRequestParameters,\n  queryOptions: QueryOptions\n): Promise<LabelNamesResponse> {\n  return fetchWithPost<LabelNamesRequestParameters, LabelNamesResponse>('/api/v1/labels', params, queryOptions);\n}\n\n/**\n * Calls the `/api/v1/label/{labelName}/values` endpoint to get a list of values for a label.\n */\nexport function labelValues(\n  params: LabelValuesRequestParameters,\n  queryOptions: QueryOptions\n): Promise<LabelValuesResponse> {\n  const { labelName, ...searchParams } = params;\n\n  // In case label name is empty, we'll receive a 404, so we can replace it by an empty list, which is less confusing.\n  // Note that an empty list is the prometheus result if the label does not exist.\n  if (labelName.length === 0) {\n    return new Promise((resolve) => {\n      resolve({ data: [] as string[] } as SuccessResponse<string[]>);\n    });\n  }\n\n  const apiURI = `/api/v1/label/${encodeURIComponent(labelName)}/values`;\n  return fetchWithGet<typeof searchParams, LabelValuesResponse>(apiURI, searchParams, queryOptions);\n}\n\n/**\n * Calls the `/api/v1/label/{labelName}/values` endpoint to get a list of values for a label.\n */\nexport function metricMetadata(\n  params: MetricMetadataRequestParameters,\n  queryOptions: QueryOptions\n): Promise<MetricMetadataResponse> {\n  const apiURI = `/api/v1/metadata`;\n  return fetchWithGet<MetricMetadataRequestParameters, MetricMetadataResponse>(apiURI, params, queryOptions);\n}\n\n/**\n * Calls the `/api/v1/series` endpoint to finding series by label matchers.\n */\nexport function series(params: SeriesRequestParameters, queryOptions: QueryOptions): Promise<SeriesResponse> {\n  const apiURI = `/api/v1/series`;\n  return fetchWithPost<SeriesRequestParameters, SeriesResponse>(apiURI, params, queryOptions);\n}\n\n/**\n * Calls the `/api/v1/parse_query` to parse the given promQL expresion into an abstract syntax tree (AST).\n */\nexport function parseQuery(\n  params: ParseQueryRequestParameters,\n  queryOptions: QueryOptions\n): Promise<ParseQueryResponse> {\n  const apiURI = `/api/v1/parse_query`;\n  return fetchWithPost<ParseQueryRequestParameters, ParseQueryResponse>(apiURI, params, queryOptions);\n}\n\nfunction fetchWithGet<T extends RequestParams<T>, TResponse>(\n  apiURI: string,\n  params: T,\n  queryOptions: QueryOptions\n): Promise<TResponse> {\n  const { datasourceUrl, headers, queryParams } = queryOptions;\n  const url = `${datasourceUrl}${apiURI}${buildQueryString(queryParams, createSearchParams(params))}`;\n  return fetchJson<TResponse>(url, { method: 'GET', headers });\n}\n\nfunction fetchWithPost<T extends RequestParams<T>, TResponse>(\n  apiURI: string,\n  params: T,\n  queryOptions: QueryOptions\n): Promise<TResponse> {\n  const { datasourceUrl, headers, abortSignal: signal, queryParams } = queryOptions;\n  const url = `${datasourceUrl}${apiURI}${buildQueryString(queryParams)}`;\n\n  const init = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      ...headers,\n    },\n    signal,\n    body: createSearchParams(params),\n  };\n  return fetchResults<TResponse>(url, init);\n}\n\n// Request parameter values we know how to serialize\ntype ParamValue = string | string[] | number | undefined;\n\n// Used to constrain the types that can be passed to createSearchParams to\n// just the ones we know how to serialize\ntype RequestParams<T> = {\n  [K in keyof T]: ParamValue;\n};\n\n/**\n * Creates URLSearchParams from a request params object.\n */\nfunction createSearchParams<T extends RequestParams<T>>(params: T): URLSearchParams {\n  const searchParams = new URLSearchParams();\n  for (const key in params) {\n    const value: ParamValue = params[key];\n    if (value === undefined) continue;\n\n    if (typeof value === 'string') {\n      searchParams.append(key, value);\n      continue;\n    }\n\n    if (typeof value === 'number') {\n      searchParams.append(key, value.toString());\n      continue;\n    }\n\n    for (const val of value) {\n      searchParams.append(key, val);\n    }\n  }\n  return searchParams;\n}\n\n/**\n * Fetch JSON and parse warnings for query inspector\n */\nexport async function fetchResults<T>(...args: Parameters<typeof global.fetch>): Promise<T> {\n  const response = await fetch(...args);\n  const json: T = await response.json();\n  return { ...json, rawResponse: response };\n}\n"],"names":["fetch","fetchJson","buildQueryString","queryParams","initialParams","urlParams","URLSearchParams","Object","entries","forEach","key","value","set","queryString","toString","healthCheck","queryOptions","url","datasourceUrl","resp","headers","signal","abortSignal","status","instantQuery","params","fetchWithPost","rangeQuery","labelNames","labelValues","labelName","searchParams","length","Promise","resolve","data","apiURI","encodeURIComponent","fetchWithGet","metricMetadata","series","parseQuery","createSearchParams","method","init","body","fetchResults","undefined","append","val","args","response","json","rawResponse"],"mappings":"AAAA,oCAAoC;AACpC,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,6CAA6C;AAC7C,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;AAEjC,SAASA,KAAK,EAAEC,SAAS,QAAwB,mBAAmB;AAmEpE;;;;CAIC,GACD,SAASC,iBAAiBC,WAAoC,EAAEC,aAA+B;IAC7F,MAAMC,YAAYD,iBAAiB,IAAIE;IAEvC,IAAIH,aAAa;QACfI,OAAOC,OAAO,CAACL,aAAaM,OAAO,CAAC,CAAC,CAACC,KAAKC,MAAM;YAC/CN,UAAUO,GAAG,CAACF,KAAKC;QACrB;IACF;IAEA,MAAME,cAAcR,UAAUS,QAAQ;IACtC,OAAOD,gBAAgB,KAAK,CAAC,CAAC,EAAEA,aAAa,GAAG;AAClD;AAEA;;CAEC,GACD,OAAO,SAASE,YAAYC,YAA0B;IACpD,OAAO;QACL,MAAMC,MAAM,GAAGD,aAAaE,aAAa,CAAC,UAAU,EAAEhB,iBAAiBc,aAAab,WAAW,GAAG;QAElG,IAAI;YACF,MAAMgB,OAAO,MAAMnB,MAAMiB,KAAK;gBAAEG,SAASJ,aAAaI,OAAO;gBAAEC,QAAQL,aAAaM,WAAW;YAAC;YAChG,OAAOH,KAAKI,MAAM,KAAK;QACzB,EAAE,OAAM;YACN,OAAO;QACT;IACF;AACF;AAEA;;CAEC,GACD,OAAO,SAASC,aACdC,MAAqC,EACrCT,YAA0B;IAE1B,OAAOU,cAAmE,iBAAiBD,QAAQT;AACrG;AAEA;;CAEC,GACD,OAAO,SAASW,WACdF,MAAmC,EACnCT,YAA0B;IAE1B,OAAOU,cAA+D,uBAAuBD,QAAQT;AACvG;AAEA;;CAEC,GACD,OAAO,SAASY,WACdH,MAAmC,EACnCT,YAA0B;IAE1B,OAAOU,cAA+D,kBAAkBD,QAAQT;AAClG;AAEA;;CAEC,GACD,OAAO,SAASa,YACdJ,MAAoC,EACpCT,YAA0B;IAE1B,MAAM,EAAEc,SAAS,EAAE,GAAGC,cAAc,GAAGN;IAEvC,oHAAoH;IACpH,gFAAgF;IAChF,IAAIK,UAAUE,MAAM,KAAK,GAAG;QAC1B,OAAO,IAAIC,QAAQ,CAACC;YAClBA,QAAQ;gBAAEC,MAAM,EAAE;YAAa;QACjC;IACF;IAEA,MAAMC,SAAS,CAAC,cAAc,EAAEC,mBAAmBP,WAAW,OAAO,CAAC;IACtE,OAAOQ,aAAuDF,QAAQL,cAAcf;AACtF;AAEA;;CAEC,GACD,OAAO,SAASuB,eACdd,MAAuC,EACvCT,YAA0B;IAE1B,MAAMoB,SAAS,CAAC,gBAAgB,CAAC;IACjC,OAAOE,aAAsEF,QAAQX,QAAQT;AAC/F;AAEA;;CAEC,GACD,OAAO,SAASwB,OAAOf,MAA+B,EAAET,YAA0B;IAChF,MAAMoB,SAAS,CAAC,cAAc,CAAC;IAC/B,OAAOV,cAAuDU,QAAQX,QAAQT;AAChF;AAEA;;CAEC,GACD,OAAO,SAASyB,WACdhB,MAAmC,EACnCT,YAA0B;IAE1B,MAAMoB,SAAS,CAAC,mBAAmB,CAAC;IACpC,OAAOV,cAA+DU,QAAQX,QAAQT;AACxF;AAEA,SAASsB,aACPF,MAAc,EACdX,MAAS,EACTT,YAA0B;IAE1B,MAAM,EAAEE,aAAa,EAAEE,OAAO,EAAEjB,WAAW,EAAE,GAAGa;IAChD,MAAMC,MAAM,GAAGC,gBAAgBkB,SAASlC,iBAAiBC,aAAauC,mBAAmBjB,UAAU;IACnG,OAAOxB,UAAqBgB,KAAK;QAAE0B,QAAQ;QAAOvB;IAAQ;AAC5D;AAEA,SAASM,cACPU,MAAc,EACdX,MAAS,EACTT,YAA0B;IAE1B,MAAM,EAAEE,aAAa,EAAEE,OAAO,EAAEE,aAAaD,MAAM,EAAElB,WAAW,EAAE,GAAGa;IACrE,MAAMC,MAAM,GAAGC,gBAAgBkB,SAASlC,iBAAiBC,cAAc;IAEvE,MAAMyC,OAAO;QACXD,QAAQ;QACRvB,SAAS;YACP,gBAAgB;YAChB,GAAGA,OAAO;QACZ;QACAC;QACAwB,MAAMH,mBAAmBjB;IAC3B;IACA,OAAOqB,aAAwB7B,KAAK2B;AACtC;AAWA;;CAEC,GACD,SAASF,mBAA+CjB,MAAS;IAC/D,MAAMM,eAAe,IAAIzB;IACzB,IAAK,MAAMI,OAAOe,OAAQ;QACxB,MAAMd,QAAoBc,MAAM,CAACf,IAAI;QACrC,IAAIC,UAAUoC,WAAW;QAEzB,IAAI,OAAOpC,UAAU,UAAU;YAC7BoB,aAAaiB,MAAM,CAACtC,KAAKC;YACzB;QACF;QAEA,IAAI,OAAOA,UAAU,UAAU;YAC7BoB,aAAaiB,MAAM,CAACtC,KAAKC,MAAMG,QAAQ;YACvC;QACF;QAEA,KAAK,MAAMmC,OAAOtC,MAAO;YACvBoB,aAAaiB,MAAM,CAACtC,KAAKuC;QAC3B;IACF;IACA,OAAOlB;AACT;AAEA;;CAEC,GACD,OAAO,eAAee,aAAgB,GAAGI,IAAqC;IAC5E,MAAMC,WAAW,MAAMnD,SAASkD;IAChC,MAAME,OAAU,MAAMD,SAASC,IAAI;IACnC,OAAO;QAAE,GAAGA,IAAI;QAAEC,aAAaF;IAAS;AAC1C"}