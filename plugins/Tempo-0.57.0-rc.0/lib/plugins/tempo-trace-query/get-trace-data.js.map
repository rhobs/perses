{"version":3,"sources":["../../../../src/plugins/tempo-trace-query/get-trace-data.ts"],"sourcesContent":["// Copyright 2025 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { AbsoluteTimeRange, isValidTraceId, Notice, otlptracev1, TraceSearchResult } from '@perses-dev/core';\nimport { datasourceSelectValueToSelector, TraceQueryPlugin } from '@perses-dev/plugin-system';\nimport { getUnixTime } from 'date-fns';\nimport { TEMPO_DATASOURCE_KIND, TempoDatasourceSelector, TempoTraceQuerySpec } from '../../model';\nimport { DEFAULT_SEARCH_LIMIT, QueryResponse, SearchRequestParameters, SearchResponse } from '../../model/api-types';\nimport { TempoClient } from '../../model/tempo-client';\n\nexport function getUnixTimeRange(timeRange: AbsoluteTimeRange): { start: number; end: number } {\n  const { start, end } = timeRange;\n  return {\n    start: Math.ceil(getUnixTime(start)),\n    end: Math.ceil(getUnixTime(end)),\n  };\n}\n\nexport const getTraceData: TraceQueryPlugin<TempoTraceQuerySpec>['getTraceData'] = async (spec, context) => {\n  if (spec.query === undefined || spec.query === null || spec.query === '') {\n    // Do not make a request to the backend, instead return an empty TraceData\n    console.error('TempoTraceQuery is undefined, null, or an empty string.');\n    return { searchResult: [] };\n  }\n\n  const defaultTempoDatasource: TempoDatasourceSelector = {\n    kind: TEMPO_DATASOURCE_KIND,\n  };\n\n  const listDatasourceSelectItems = await context.datasourceStore.listDatasourceSelectItems(TEMPO_DATASOURCE_KIND);\n  const datasourceSelector =\n    datasourceSelectValueToSelector(spec.datasource, context.variableState, listDatasourceSelectItems) ??\n    defaultTempoDatasource;\n\n  const client = await context.datasourceStore.getDatasourceClient<TempoClient>(datasourceSelector);\n\n  /**\n   * determine type of query:\n   * if the query is a valid traceId, fetch the trace by traceId\n   * otherwise, execute a TraceQL query\n   */\n  if (isValidTraceId(spec.query)) {\n    const response = await client.query({ traceId: spec.query });\n    return {\n      trace: parseTraceResponse(response),\n      metadata: {\n        executedQueryString: spec.query,\n      },\n    };\n  } else {\n    const params: SearchRequestParameters = {\n      q: spec.query,\n    };\n\n    // handle time range selection from UI drop down (e.g. last 5 minutes, last 1 hour )\n    if (context.absoluteTimeRange) {\n      const { start, end } = getUnixTimeRange(context.absoluteTimeRange);\n      params.start = start;\n      params.end = end;\n    }\n\n    // Fetch one more trace than requested.\n    // This way we can check if there are more traces available matching the search request, and show a notice to the user.\n    const limit = spec.limit ?? DEFAULT_SEARCH_LIMIT;\n    params.limit = limit + 1;\n\n    const response = await client.searchWithFallback(params);\n    const searchResult = parseSearchResponse(response);\n    const hasMoreResults = searchResult.length > limit;\n\n    const notices: Notice[] = [];\n    if (hasMoreResults) {\n      notices.push({\n        type: 'info',\n        message:\n          'Not all matching traces are currently displayed. Increase the result limit to view additional traces.',\n      });\n\n      // Remove the extra element, i.e. do not return more results than requested.\n      searchResult.splice(limit);\n    }\n\n    return {\n      searchResult,\n      metadata: {\n        executedQueryString: spec.query,\n        hasMoreResults,\n        notices,\n      },\n    };\n  }\n};\n\nfunction parseTraceResponse(response: QueryResponse): otlptracev1.TracesData {\n  const trace = {\n    resourceSpans: response.batches,\n  };\n\n  // Tempo returns Trace ID and Span ID base64-encoded.\n  // The OTLP spec defines the encoding in the hex format:\n  // Spec: https://opentelemetry.io/docs/specs/otel/trace/api/#retrieving-the-traceid-and-spanid\n  // Therefore, let's convert it to hex encoding.\n  for (const resourceSpan of trace.resourceSpans) {\n    for (const scopeSpan of resourceSpan.scopeSpans) {\n      for (const span of scopeSpan.spans) {\n        if (span.traceId.length != 32) {\n          span.traceId = base64ToHex(span.traceId);\n        }\n        if (span.spanId.length != 16) {\n          span.spanId = base64ToHex(span.spanId);\n        }\n        if (span.parentSpanId && span.parentSpanId.length != 16) {\n          span.parentSpanId = base64ToHex(span.parentSpanId);\n        }\n\n        for (const link of span.links ?? []) {\n          if (link.traceId.length != 32) {\n            link.traceId = base64ToHex(link.traceId);\n          }\n          if (link.spanId.length != 16) {\n            link.spanId = base64ToHex(link.spanId);\n          }\n        }\n      }\n    }\n  }\n\n  return trace;\n}\n\nfunction base64ToHex(str: string) {\n  try {\n    return atob(str)\n      .split('')\n      .map((char) => char.charCodeAt(0).toString(16).padStart(2, '0'))\n      .join('');\n  } catch {\n    return str;\n  }\n}\n\nfunction parseSearchResponse(response: SearchResponse): TraceSearchResult[] {\n  return response.traces.map((trace) => ({\n    startTimeUnixMs: parseInt(trace.startTimeUnixNano) * 1e-6, // convert to millisecond for eChart time format,\n    durationMs: trace.durationMs ?? 0, // Tempo API doesn't return 0 values\n    traceId: trace.traceID,\n    rootServiceName: trace.rootServiceName,\n    rootTraceName: trace.rootTraceName,\n    serviceStats: trace.serviceStats || {},\n  }));\n}\n"],"names":["isValidTraceId","datasourceSelectValueToSelector","getUnixTime","TEMPO_DATASOURCE_KIND","DEFAULT_SEARCH_LIMIT","getUnixTimeRange","timeRange","start","end","Math","ceil","getTraceData","spec","context","query","undefined","console","error","searchResult","defaultTempoDatasource","kind","listDatasourceSelectItems","datasourceStore","datasourceSelector","datasource","variableState","client","getDatasourceClient","response","traceId","trace","parseTraceResponse","metadata","executedQueryString","params","q","absoluteTimeRange","limit","searchWithFallback","parseSearchResponse","hasMoreResults","length","notices","push","type","message","splice","resourceSpans","batches","resourceSpan","scopeSpan","scopeSpans","span","spans","base64ToHex","spanId","parentSpanId","link","links","str","atob","split","map","char","charCodeAt","toString","padStart","join","traces","startTimeUnixMs","parseInt","startTimeUnixNano","durationMs","traceID","rootServiceName","rootTraceName","serviceStats"],"mappings":"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"}