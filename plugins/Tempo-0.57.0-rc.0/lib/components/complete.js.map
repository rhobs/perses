{"version":3,"sources":["../../../src/components/complete.ts"],"sourcesContent":["// Copyright 2024 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Completion, CompletionContext, CompletionResult, insertCompletionText } from '@codemirror/autocomplete';\nimport { syntaxTree } from '@codemirror/language';\nimport { EditorState } from '@codemirror/state';\nimport { Tree } from '@lezer/common';\nimport {\n  String as StringType,\n  FieldExpression,\n  AttributeField,\n  Resource,\n  Identifier,\n  Span,\n  SpansetFilter,\n  FieldOp,\n} from '@grafana/lezer-traceql';\nimport { EditorView } from '@uiw/react-codemirror';\nimport { getUnixTimeRange } from '../plugins/tempo-trace-query';\nimport { CompletionConfig } from './TraceQLExtension';\n\n/** CompletionScope specifies the completion kind, e.g. whether to complete tag names or values etc. */\ntype CompletionScope =\n  | { kind: 'Scopes' } // 'resource'|'span'\n  | { kind: 'TagName'; scope: 'resource' | 'span' | 'intrinsic' }\n  | { kind: 'TagValue'; tag: string };\n\n/**\n * Completions specifies the identified scopes and position of the completion in the current editor text.\n * For example, when entering '{' the following completions are possible: Scopes(), TagName(scope=intrinsic)\n */\nexport interface Completions {\n  scopes: CompletionScope[];\n  from: number;\n  to?: number;\n}\n\nconst quoteChars = ['\"', '`'];\nconst defaultQuoteChar = '\"';\n\nexport async function complete(\n  completionCfg: CompletionConfig,\n  { state, pos }: CompletionContext\n): Promise<CompletionResult | null> {\n  // First, identify the completion scopes, for example Scopes() and TagName(scope=intrinsic)\n  const completions = identifyCompletions(state, pos, syntaxTree(state));\n  if (!completions) {\n    // No completion scopes found for current cursor position.\n    return null;\n  }\n\n  // Then, retrieve completion options for all identified scopes (from the Tempo API).\n  const options = await retrieveOptions(completionCfg, completions.scopes);\n  return { options, from: completions.from, to: completions.to };\n}\n\n/**\n * Identify completion scopes (e.g. TagValue) and position, based on the current node in the syntax tree.\n *\n * For development, you can visualize the tree of a TraceQL query using this tool:\n * https://github.com/grafana/lezer-traceql/blob/main/tools/tree-viz.html\n *\n * Function is exported for tests only.\n */\nexport function identifyCompletions(state: EditorState, pos: number, tree: Tree): Completions | undefined {\n  const node = tree.resolveInner(pos, -1);\n\n  switch (node.type.id) {\n    case SpansetFilter:\n      // autocomplete {\n      // autocomplete {}\n      // do not autocomplete if cursor is after } or { status=ok }\n      if (\n        (node.firstChild === null || node.firstChild?.type.id === 0) &&\n        !state.sliceDoc(node.from, pos).includes('}')\n      ) {\n        return {\n          scopes: [{ kind: 'Scopes' }, { kind: 'TagName', scope: 'intrinsic' }],\n          from: pos,\n        };\n      }\n      break;\n\n    case FieldExpression:\n      // autocomplete { status=ok &&\n      return {\n        scopes: [{ kind: 'Scopes' }, { kind: 'TagName', scope: 'intrinsic' }],\n        from: pos,\n      };\n\n    case AttributeField:\n      // autocomplete { resource.\n      if (node.firstChild?.type.id === Resource) {\n        return { scopes: [{ kind: 'TagName', scope: 'resource' }], from: pos };\n      }\n\n      // autocomplete { span.\n      if (node.firstChild?.type.id === Span) {\n        return { scopes: [{ kind: 'TagName', scope: 'span' }], from: pos };\n      }\n\n      // autocomplete { .\n      if (state.sliceDoc(node.from, node.to) === '.') {\n        return {\n          scopes: [\n            { kind: 'TagName', scope: 'resource' },\n            { kind: 'TagName', scope: 'span' },\n          ],\n          from: pos,\n        };\n      }\n      break;\n\n    case Identifier:\n      if (node.parent?.type.id === AttributeField) {\n        const text = state.sliceDoc(node.parent.from, node.parent.to);\n        // autocomplete { span:s\n        // only intrinsic fields can have a : in the name.\n        if (text.includes(':')) {\n          return { scopes: [{ kind: 'TagName', scope: 'intrinsic' }], from: node.parent.from };\n        }\n\n        // autocomplete { resource.s\n        if (node.parent?.firstChild?.type.id === Resource) {\n          return { scopes: [{ kind: 'TagName', scope: 'resource' }], from: node.from };\n        }\n\n        // autocomplete { span.s\n        if (node.parent?.firstChild?.type.id === Span) {\n          return { scopes: [{ kind: 'TagName', scope: 'span' }], from: node.from };\n        }\n\n        // autocomplete { .s\n        if (node.parent?.firstChild?.type.id === Identifier) {\n          return {\n            scopes: [\n              { kind: 'TagName', scope: 'resource' },\n              { kind: 'TagName', scope: 'span' },\n            ],\n            from: node.from,\n          };\n        }\n      }\n      break;\n\n    case FieldOp:\n      // autocomplete { status=\n      // autocomplete { span.http.method=\n      if (node.parent?.firstChild?.type.id === FieldExpression) {\n        const fieldExpr = node.parent.firstChild;\n        const attribute = state.sliceDoc(fieldExpr.from, fieldExpr.to);\n        return { scopes: [{ kind: 'TagValue', tag: attribute }], from: pos };\n      }\n      break;\n\n    case StringType:\n      // autocomplete { resource.service.name=\"\n      // do not autocomplete if cursor is after closing quotes { resource.service.name=\"\"\n      if (\n        node.parent?.parent?.parent?.firstChild?.type.id === FieldExpression &&\n        !/^\".*\"$/.test(state.sliceDoc(node.from, pos))\n      ) {\n        const fieldExpr = node.parent.parent.parent.firstChild;\n        const attribute = state.sliceDoc(fieldExpr.from, fieldExpr.to);\n        return { scopes: [{ kind: 'TagValue', tag: attribute }], from: node.from + 1 }; // node.from+1 to ignore leading \"\n      }\n      break;\n\n    case 0 /* error node */:\n      // autocomplete { status=e\n      if (node.prevSibling?.type.id === FieldOp && node.parent?.firstChild?.type.id === FieldExpression) {\n        const fieldExpr = node.parent.firstChild;\n        const attribute = state.sliceDoc(fieldExpr.from, fieldExpr.to);\n        // ignore leading \" in { name=\"HT\n        const from = quoteChars.includes(state.sliceDoc(node.from, node.from + 1)) ? node.from + 1 : node.from;\n        return { scopes: [{ kind: 'TagValue', tag: attribute }], from };\n      }\n\n      // autocomplete { s\n      // autocomplete { status=ok && s\n      if (node.parent?.type.id === SpansetFilter || node.parent?.type.id === FieldExpression) {\n        return {\n          scopes: [{ kind: 'Scopes' }, { kind: 'TagName', scope: 'intrinsic' }],\n          from: node.from,\n        };\n      }\n      break;\n  }\n}\n\n/**\n * Retrieve all completion options based on the previously identified completion scopes.\n */\nasync function retrieveOptions(completionCfg: CompletionConfig, completions: CompletionScope[]): Promise<Completion[]> {\n  const results: Array<Promise<Completion[]>> = [];\n\n  for (const completion of completions) {\n    switch (completion.kind) {\n      case 'Scopes':\n        results.push(Promise.resolve([{ label: 'span' }, { label: 'resource' }]));\n        break;\n\n      case 'TagName':\n        results.push(completeTagName(completionCfg, completion.scope));\n        break;\n\n      case 'TagValue':\n        results.push(completeTagValue(completionCfg, completion.tag));\n        break;\n    }\n  }\n\n  // Retrieve options concurrently\n  // e.g. for unscoped attribute fields, retrieve list of span and resource attributes concurrently.\n  const options = await Promise.all(results);\n  return options.flat();\n}\n\nasync function completeTagName(\n  completionCfg: CompletionConfig,\n  scope: 'resource' | 'span' | 'intrinsic'\n): Promise<Completion[]> {\n  if (!completionCfg.client) {\n    return [];\n  }\n\n  const { start, end } = completionCfg.timeRange ? getUnixTimeRange(completionCfg.timeRange) : {};\n  const { limit, maxStaleValues } = completionCfg;\n\n  const response = await completionCfg.client.searchTags({ scope, start, end, limit, maxStaleValues });\n  return response.scopes.flatMap((scope) => scope.tags).map((tag) => ({ label: tag }));\n}\n\nfunction escapeString(input: string, quoteChar: string) {\n  // do not escape raw strings (when using backticks)\n  if (quoteChar === '`') {\n    return input;\n  }\n\n  let escaped = input;\n  // escape sequences: https://grafana.com/docs/tempo/v2.8.x/traceql/construct-traceql-queries/#quoted-attribute-names\n  escaped = escaped.replaceAll('\\\\', '\\\\\\\\');\n  escaped = escaped.replaceAll('\"', '\\\\\"');\n  return escaped;\n}\n\n/**\n * Add quotes to the completion text in case quotes are not present already.\n * This handles the following cases:\n * { name=HTTP\n * { name=\"x\n * { name=\"x\" where cursor is after the 'x'\n */\nexport function applyQuotedCompletion(view: EditorView, completion: Completion, from: number, to: number): void {\n  let quoteChar = defaultQuoteChar;\n  if (quoteChars.includes(view.state.sliceDoc(from - 1, from))) {\n    quoteChar = view.state.sliceDoc(from - 1, from);\n    from--;\n  }\n  if (quoteChars.includes(view.state.sliceDoc(to, to + 1))) {\n    quoteChar = view.state.sliceDoc(to, to + 1);\n    to++;\n  }\n\n  // When using raw strings (`), we cannot escape a backtick.\n  // Therefore, switch the quote character.\n  if (completion.label.includes('`')) {\n    quoteChar = '\"';\n  }\n\n  const insertText = `${quoteChar}${escapeString(completion.label, quoteChar)}${quoteChar}`;\n  view.dispatch(insertCompletionText(view.state, insertText, from, to));\n}\n\nasync function completeTagValue(completionCfg: CompletionConfig, tag: string): Promise<Completion[]> {\n  if (!completionCfg.client) {\n    return [];\n  }\n\n  const { start, end } = completionCfg.timeRange ? getUnixTimeRange(completionCfg.timeRange) : {};\n  const { limit, maxStaleValues } = completionCfg;\n\n  const response = await completionCfg.client.searchTagValues({ tag, start, end, limit, maxStaleValues });\n  const completions: Completion[] = [];\n  for (const { type, value } of response.tagValues) {\n    switch (type) {\n      case 'string':\n        completions.push({ label: value ?? '', displayLabel: value ?? '(empty string)', apply: applyQuotedCompletion });\n        break;\n\n      case 'keyword':\n      case 'int':\n        completions.push({ label: value ?? '', displayLabel: value ?? '(empty string)' });\n        break;\n    }\n  }\n  return completions;\n}\n"],"names":["insertCompletionText","syntaxTree","String","StringType","FieldExpression","AttributeField","Resource","Identifier","Span","SpansetFilter","FieldOp","getUnixTimeRange","quoteChars","defaultQuoteChar","complete","completionCfg","state","pos","completions","identifyCompletions","options","retrieveOptions","scopes","from","to","tree","node","resolveInner","type","id","firstChild","sliceDoc","includes","kind","scope","parent","text","fieldExpr","attribute","tag","test","prevSibling","results","completion","push","Promise","resolve","label","completeTagName","completeTagValue","all","flat","client","start","end","timeRange","limit","maxStaleValues","response","searchTags","flatMap","tags","map","escapeString","input","quoteChar","escaped","replaceAll","applyQuotedCompletion","view","insertText","dispatch","searchTagValues","value","tagValues","displayLabel","apply"],"mappings":"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"}