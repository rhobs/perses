{"version":3,"sources":["../../../../src/components/filter/traceql_to_filter.ts"],"sourcesContent":["import { AttributeField, FieldExpression, FieldOp, IntrinsicField, Static, parser } from '@grafana/lezer-traceql';\nimport { DurationField, Filter } from './filter';\n\ninterface Matcher {\n  operator: string;\n  value: string;\n}\n\n/**\n * Construct a Filter from a TraceQL query.\n * 1. Parse the query (using Lezer library) and extract all matchers, e.g. 'some_attribute = \"some_value\"'\n * 2. Create the filter attribute values, a string array with a single value (for 'x = \"y\"') or multiple values (for 'x =~ \"y|z\"')\n * 3. Add the remaining matchers to the set of custom matchers.\n */\nexport function traceQLToFilter(query: string): Filter {\n  const matchers = parseQuery(query);\n  return {\n    serviceName: reverseStringMatcher(matchers['resource.service.name']),\n    spanName: reverseStringMatcher(matchers['name']),\n    namespace: reverseStringMatcher(matchers['resource.k8s.namespace.name']),\n    status: reverseIntrinsicMatcher(matchers['status']),\n    spanDuration: reverseDurationMatcher(matchers['duration']),\n    traceDuration: reverseDurationMatcher(matchers['traceDuration']),\n    customMatchers: reverseCustomMatcher(\n      matchers,\n      new Set(['resource.service.name', 'name', 'resource.k8s.namespace.name', 'status', 'duration', 'traceDuration'])\n    ),\n  };\n}\n\nfunction parseQuery(query: string) {\n  const matchers: Record<string, Matcher[]> = {};\n  let attribute = '';\n  let operator = '';\n  let value = '';\n\n  const syntaxTree = parser.parse(query);\n  syntaxTree.iterate({\n    enter(node) {\n      switch (node.type.id) {\n        case AttributeField:\n          attribute = query.slice(node.from, node.to);\n          return false;\n        case IntrinsicField:\n          attribute = query.slice(node.from, node.to);\n          return false;\n        case FieldOp:\n          operator = query.slice(node.from, node.to);\n          return false;\n        case Static:\n          value = query.slice(node.from, node.to);\n          return false;\n      }\n    },\n    leave(node) {\n      if (node.type.id === FieldExpression && node.node.getChild(FieldOp)) {\n        const newMatchers = matchers[attribute] ?? [];\n        newMatchers.push({ operator, value });\n        matchers[attribute] = newMatchers;\n      }\n    },\n  });\n\n  return matchers;\n}\n\nfunction unescape(q: string) {\n  return q.replaceAll('\\\\\"', '\"').replaceAll('\\\\\\\\', '\\\\');\n}\n\nfunction reverseStringMatcher(matches?: Matcher[]) {\n  const values: string[] = [];\n  for (const { operator, value } of matches ?? []) {\n    const unescaped = unescape(value.slice(1, -1));\n    if (operator == '=') {\n      values.push(unescaped);\n    } else if (operator == '=~') {\n      values.push(...unescaped.split('|'));\n    }\n  }\n  return values;\n}\n\nfunction reverseIntrinsicMatcher(matches?: Matcher[]) {\n  const values: string[] = [];\n  for (const { operator, value } of matches ?? []) {\n    if (operator == '=') {\n      values.push(value);\n    }\n  }\n  return values;\n}\n\nfunction reverseDurationMatcher(matches?: Matcher[]) {\n  const duration: DurationField = {};\n  for (const { operator, value } of matches ?? []) {\n    if (operator == '>=') {\n      duration.min = value;\n    } else if (operator == '<=') {\n      duration.max = value;\n    }\n  }\n  return duration;\n}\n\nfunction reverseCustomMatcher(matchers: Record<string, Matcher[]>, skipAttrs: Set<string>) {\n  const customMatchers: string[] = [];\n  for (const [attribute, matches] of Object.entries(matchers)) {\n    if (skipAttrs.has(attribute)) {\n      continue;\n    }\n\n    for (const { operator, value } of matches) {\n      customMatchers.push(`${attribute}${operator}${value}`);\n    }\n  }\n  return customMatchers;\n}\n"],"names":["AttributeField","FieldExpression","FieldOp","IntrinsicField","Static","parser","traceQLToFilter","query","matchers","parseQuery","serviceName","reverseStringMatcher","spanName","namespace","status","reverseIntrinsicMatcher","spanDuration","reverseDurationMatcher","traceDuration","customMatchers","reverseCustomMatcher","Set","attribute","operator","value","syntaxTree","parse","iterate","enter","node","type","id","slice","from","to","leave","getChild","newMatchers","push","unescape","q","replaceAll","matches","values","unescaped","split","duration","min","max","skipAttrs","Object","entries","has"],"mappings":"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"}