{"version":3,"sources":["../../../src/utils/data-transform.ts"],"sourcesContent":["// Copyright 2025 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { ProfileMetaData, StackTrace } from '@perses-dev/core';\nimport { FlameChartSample as Sample, TableChartSample } from './data-model';\nimport { getSpanColor } from './palette-gen';\nimport { formatItemValue } from './format';\n\n/**\n * Filter the global stacktrace by a function ID to focus on that function and display its corresponding flame chart\n */\nexport function filterStackTraceById(trace: StackTrace, id: number | undefined): StackTrace {\n  if (id === undefined) {\n    return trace;\n  }\n\n  const recur = (trace: StackTrace, id: number | undefined): StackTrace | undefined => {\n    if (trace.id === id) {\n      return trace;\n    }\n\n    for (const child of trace.children ?? []) {\n      const temp = recur(child, id);\n      if (temp) {\n        trace = { ...trace }; // Create a shallow copy of the trace to avoid mutating the original object\n        // Override parents' values\n        trace.children = [temp];\n        trace.start = temp.start;\n        trace.end = temp.end;\n\n        return trace;\n      }\n    }\n\n    return undefined;\n  };\n\n  return recur(trace, id) ?? trace;\n}\n\n// build the name of the corresponding flamechart item\nfunction formatName(item: StackTrace, rootVal: number, unit: string | undefined): string {\n  return (item.total / rootVal) * 100 < 1 ? '' : item.name + ` (${formatItemValue(unit, item.total)})`;\n}\n\n/**\n * Search the total value of an item corresponding to a given ID\n */\nfunction getCurrentTotalValue(json: StackTrace, id: number | undefined): number {\n  if (id === undefined) return 0;\n\n  const recur = (item: StackTrace): number => {\n    if (item.id === id) {\n      return item.total;\n    }\n\n    for (const child of item.children || []) {\n      const total = recur(child);\n      if (total !== undefined) {\n        return total;\n      }\n    }\n    return 0; // If not found, return 0\n  };\n\n  return recur(json);\n}\n\n/**\n * Build series data for the flame chart option\n */\nexport function buildSamples(\n  palette: string,\n  metadata: ProfileMetaData | undefined,\n  traces: StackTrace,\n  searchValue: string,\n  id?: number\n): Sample[] {\n  const data: Sample[] = [];\n  const filteredJson = filterStackTraceById(traces, id);\n\n  const rootVal = filteredJson.total; // total samples of root node\n  const currentVal = getCurrentTotalValue(filteredJson, id); // total samples of the selected item, used to generate items colors\n\n  const recur = (item: StackTrace): void => {\n    const temp = {\n      name: item.id,\n      value: [\n        item.level,\n        item.start,\n        item.end,\n        formatName(item, currentVal ? currentVal : rootVal, metadata?.units),\n        (item.total / rootVal) * 100,\n        (item.self / rootVal) * 100,\n        item.name,\n        item.self,\n        item.total,\n      ],\n      itemStyle: {\n        color: !isItemNameMatchesSearchFilters(item.name, searchValue)\n          ? '#dee2e6'\n          : getSpanColor(palette, item.name, (item.total / (currentVal ? currentVal : rootVal)) * 100),\n      },\n    };\n    data.push(temp as Sample);\n\n    for (const child of item.children || []) {\n      recur(child);\n    }\n  };\n\n  // check is filteredJson is not empty before call recur\n  if (filteredJson.id) recur(filteredJson);\n  return data;\n}\n\n/**\n * Transform query results to a tabular format for the table chart\n */\nexport function tableRecursionJson(jsonObj: StackTrace, searchValue: string): TableChartSample[] {\n  const data: TableChartSample[] = [];\n  const structuredJson = structuredClone(jsonObj);\n\n  const recur = (item: StackTrace): void => {\n    const temp = {\n      id: item.id,\n      name: item.name,\n      self: item.self,\n      total: item.total,\n    };\n\n    if (isItemNameMatchesSearchFilters(temp.name, searchValue)) data.push(temp as TableChartSample);\n\n    for (const child of item.children || []) {\n      recur(child);\n    }\n  };\n\n  // check is structuredJson is not empty before call recur\n  if (structuredJson.id) recur(structuredJson);\n  return data;\n}\n\n// Checks if an item name matches all parts of a search value.\nfunction isItemNameMatchesSearchFilters(itemName: string, searchValue: string): boolean {\n  if (searchValue === '') return true;\n\n  const filters = searchValue\n    .trim()\n    .toLocaleLowerCase()\n    .split(/[^a-zA-Z0-9']+/)\n    .filter((s) => s !== '');\n\n  if (filters.length === 0) {\n    return false;\n  } else {\n    return filters.every((filter) => itemName.toLowerCase().includes(filter.trim()));\n  }\n}\n\n/**\n * Finds the total sample value of the series data item with the specified name.\n */\nexport function findTotalSampleByName(seriesData: Sample[], name: number | undefined): number | undefined {\n  if (name === undefined || name === 0) return undefined;\n  const item = seriesData.find((item) => item.name === name);\n  const totalSample = item?.value[8];\n  return Number(totalSample);\n}\n\n/*\n * Calculate the maximum depth of the stack trace\n */\nexport function getMaxDepth(trace: StackTrace): number {\n  if (!trace.children?.length) {\n    return 1;\n  }\n  return 1 + Math.max(...trace.children.map(getMaxDepth));\n}\n"],"names":["getSpanColor","formatItemValue","filterStackTraceById","trace","id","undefined","recur","child","children","temp","start","end","formatName","item","rootVal","unit","total","name","getCurrentTotalValue","json","buildSamples","palette","metadata","traces","searchValue","data","filteredJson","currentVal","value","level","units","self","itemStyle","color","isItemNameMatchesSearchFilters","push","tableRecursionJson","jsonObj","structuredJson","structuredClone","itemName","filters","trim","toLocaleLowerCase","split","filter","s","length","every","toLowerCase","includes","findTotalSampleByName","seriesData","find","totalSample","Number","getMaxDepth","Math","max","map"],"mappings":"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"}