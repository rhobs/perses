{"version":3,"sources":["../../src/CSVExportUtils.ts"],"sourcesContent":["// Copyright 2023 The Perses Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport interface SeriesDataPoint {\n  timestamp: number | string;\n  value: unknown;\n}\n\nexport interface DataSeries {\n  name?: string;\n  formattedName?: string;\n  legendName?: string;\n  displayName?: string;\n  legend?: string;\n  labels?: Record<string, string>;\n  values: Array<[number | string, unknown]> | SeriesDataPoint[];\n}\n\nexport interface ExportableData {\n  series: DataSeries[];\n  timeRange?: {\n    start: string | number;\n    end: string | number;\n  };\n  stepMs?: number;\n  metadata?: Record<string, unknown>;\n}\n\nexport const isExportableData = (data: unknown): data is ExportableData => {\n  return !!(\n    data &&\n    typeof data === 'object' &&\n    'series' in data &&\n    Array.isArray((data as ExportableData).series) &&\n    (data as ExportableData).series.length > 0\n  );\n};\n\nexport interface QueryDataInput {\n  data?: unknown;\n  error?: unknown;\n  isFetching?: boolean;\n}\n\nexport const extractExportableData = (queryResults: QueryDataInput[]): ExportableData | undefined => {\n  if (!queryResults || queryResults.length === 0) return undefined;\n\n  const allSeries: DataSeries[] = [];\n  let timeRange: ExportableData['timeRange'] = undefined;\n  let stepMs: number | undefined = undefined;\n  let metadata: ExportableData['metadata'] = undefined;\n\n  queryResults.forEach((query) => {\n    if (query?.data && typeof query.data === 'object' && 'series' in query.data) {\n      const data = query.data as ExportableData;\n      if (data.series && Array.isArray(data.series) && data.series.length > 0) {\n        allSeries.push(...data.series);\n        if (!timeRange && data.timeRange) {\n          timeRange = data.timeRange;\n        }\n        if (!stepMs && data.stepMs) {\n          stepMs = data.stepMs;\n        }\n        if (!metadata && data.metadata) {\n          metadata = data.metadata;\n        }\n      }\n    }\n  });\n\n  if (allSeries.length > 0) {\n    return {\n      series: allSeries,\n      timeRange,\n      stepMs,\n      metadata,\n    };\n  }\n\n  return undefined;\n};\n\nexport const formatLegendName = (series: DataSeries, seriesIndex: number): string => {\n  const seriesAny = series as DataSeries & {\n    formattedName?: string;\n    legendName?: string;\n    displayName?: string;\n    legend?: string;\n    labels?: Record<string, string>;\n  };\n\n  let legendName = series.formattedName || series.name;\n\n  if (!legendName || legendName === `Series ${seriesIndex + 1}`) {\n    legendName = seriesAny.legendName || seriesAny.displayName || seriesAny.legend || series.name || '';\n  }\n\n  if ((!legendName || legendName === series.name) && series.labels) {\n    const labels = series.labels;\n    const displayLabels = { ...labels };\n    const metricName = displayLabels.__name__;\n    delete displayLabels.__name__;\n\n    const labelPairs = Object.entries(displayLabels)\n      .filter(([value]) => value !== undefined && value !== null && value !== '')\n      .map(([key, value]) => `${key}=\"${value}\"`)\n      .join(', ');\n\n    if (metricName && labelPairs) {\n      legendName = `${metricName}{${labelPairs}}`;\n    } else if (metricName) {\n      legendName = metricName;\n    } else if (labelPairs) {\n      legendName = `{${labelPairs}}`;\n    } else {\n      legendName = labels.job || labels.instance || labels.metric || `Series ${seriesIndex + 1}`;\n    }\n  }\n\n  if (!legendName || legendName.trim() === '') {\n    legendName = `Series ${seriesIndex + 1}`;\n  }\n\n  return legendName;\n};\n\nexport const sanitizeColumnName = (name: string): string => {\n  return name\n    .replace(/[,\"\\n\\r]/g, '_')\n    .replace(/\\s+/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '')\n    .substring(0, 255);\n};\n\nexport const sanitizeFilename = (filename: string): string => {\n  return filename\n    .replace(/[<>:\"/\\\\|?*]/g, ' ')\n    .trim()\n    .split(/\\s+/)\n    .filter((word) => word.length > 0)\n    .map((word, index) => {\n      if (index === 0) {\n        return word.toLowerCase();\n      }\n      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join('');\n};\n\nexport const formatTimestampISO = (timestamp: number | string): string => {\n  let timestampMs: number;\n\n  if (typeof timestamp === 'string') {\n    const date = new Date(timestamp);\n    if (isNaN(date.getTime())) {\n      return timestamp;\n    }\n    timestampMs = date.getTime();\n  } else {\n    timestampMs = timestamp > 1e10 ? timestamp : timestamp * 1000;\n  }\n\n  const date = new Date(timestampMs);\n  if (isNaN(date.getTime())) {\n    return new Date(timestampMs).toISOString();\n  }\n\n  return date.toISOString();\n};\n\nexport const escapeCsvValue = (value: unknown): string => {\n  if (value === null || value === undefined) {\n    return '';\n  }\n\n  const stringValue = String(value);\n\n  if (\n    stringValue.includes(',') ||\n    stringValue.includes('\"') ||\n    stringValue.includes('\\n') ||\n    stringValue.includes('\\r')\n  ) {\n    return `\"${stringValue.replace(/\"/g, '\"\"')}\"`;\n  }\n\n  return stringValue;\n};\n\nexport interface ExportDataOptions {\n  data: ExportableData;\n}\n\nexport const exportDataAsCSV = ({ data }: ExportDataOptions): Blob => {\n  if (!isExportableData(data)) {\n    console.warn('No valid data found to export to CSV.');\n    return new Blob([''], { type: 'text/csv;charset=utf-8' });\n  }\n\n  let csvString = '';\n  const result: Record<string, Record<string, unknown>> = {};\n  const seriesInfo: Array<{ legendName: string; columnName: string; originalName: string }> = [];\n  let validSeriesCount = 0;\n\n  for (let i = 0; i < data.series.length; i++) {\n    const series = data.series[i];\n\n    if (!series) {\n      continue;\n    }\n\n    if (!Array.isArray(series.values) || series.values.length === 0) {\n      continue;\n    }\n\n    const legendName = formatLegendName(series, i);\n    const columnName = sanitizeColumnName(legendName);\n\n    const currentSeriesInfo = {\n      legendName,\n      columnName: columnName || `Series_${i + 1}`,\n      originalName: series.name || '',\n    };\n\n    seriesInfo.push(currentSeriesInfo);\n    validSeriesCount++;\n\n    for (let j = 0; j < series.values.length; j++) {\n      const entry = series.values[j];\n\n      let timestamp: number | string;\n      let value: unknown;\n\n      if (Array.isArray(entry) && entry.length >= 2) {\n        timestamp = entry[0];\n        value = entry[1];\n      } else if (typeof entry === 'object' && entry !== null && 'timestamp' in entry && 'value' in entry) {\n        const dataPoint = entry as SeriesDataPoint;\n        timestamp = dataPoint.timestamp;\n        value = dataPoint.value;\n      } else {\n        continue;\n      }\n\n      if (value === null || value === undefined) {\n        continue;\n      }\n\n      const dateTime = formatTimestampISO(timestamp);\n\n      if (!result[dateTime]) {\n        result[dateTime] = {};\n      }\n\n      result[dateTime][currentSeriesInfo.columnName] = value;\n    }\n  }\n\n  if (validSeriesCount === 0 || seriesInfo.length === 0) {\n    console.warn('No valid data found to export to CSV.');\n    return new Blob([''], { type: 'text/csv;charset=utf-8' });\n  }\n\n  const timestampCount = Object.keys(result).length;\n  if (timestampCount === 0) {\n    console.warn('No valid timestamp data found to export to CSV.');\n    return new Blob([''], { type: 'text/csv;charset=utf-8' });\n  }\n\n  const columnNames = seriesInfo.map((info) => info.columnName);\n  csvString += `DateTime,${columnNames.join(',')}\\n`;\n\n  const sortedDateTimes = Object.keys(result).sort((a, b) => {\n    const dateA = new Date(a).getTime();\n    const dateB = new Date(b).getTime();\n    return dateA - dateB;\n  });\n\n  for (const dateTime of sortedDateTimes) {\n    const rowData = result[dateTime];\n    const values: string[] = [];\n\n    if (rowData) {\n      for (const columnName of columnNames) {\n        const value = rowData[columnName];\n        values.push(escapeCsvValue(value));\n      }\n\n      csvString += `${escapeCsvValue(dateTime)},${values.join(',')}\\n`;\n    }\n  }\n\n  return new Blob([csvString], { type: 'text/csv;charset=utf-8' });\n};\n"],"names":["isExportableData","data","Array","isArray","series","length","extractExportableData","queryResults","undefined","allSeries","timeRange","stepMs","metadata","forEach","query","push","formatLegendName","seriesIndex","seriesAny","legendName","formattedName","name","displayName","legend","labels","displayLabels","metricName","__name__","labelPairs","Object","entries","filter","value","map","key","join","job","instance","metric","trim","sanitizeColumnName","replace","substring","sanitizeFilename","filename","split","word","index","toLowerCase","charAt","toUpperCase","slice","formatTimestampISO","timestamp","timestampMs","date","Date","isNaN","getTime","toISOString","escapeCsvValue","stringValue","String","includes","exportDataAsCSV","console","warn","Blob","type","csvString","result","seriesInfo","validSeriesCount","i","values","columnName","currentSeriesInfo","originalName","j","entry","dataPoint","dateTime","timestampCount","keys","columnNames","info","sortedDateTimes","sort","a","b","dateA","dateB","rowData"],"mappings":"AAAA,oCAAoC;AACpC,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,6CAA6C;AAC7C,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;AA2BjC,OAAO,MAAMA,mBAAmB,CAACC;IAC/B,OAAO,CAAC,CACNA,CAAAA,QACA,OAAOA,SAAS,YAChB,YAAYA,QACZC,MAAMC,OAAO,CAAC,AAACF,KAAwBG,MAAM,KAC7C,AAACH,KAAwBG,MAAM,CAACC,MAAM,GAAG,CAAA;AAE7C,EAAE;AAQF,OAAO,MAAMC,wBAAwB,CAACC;IACpC,IAAI,CAACA,gBAAgBA,aAAaF,MAAM,KAAK,GAAG,OAAOG;IAEvD,MAAMC,YAA0B,EAAE;IAClC,IAAIC,YAAyCF;IAC7C,IAAIG,SAA6BH;IACjC,IAAII,WAAuCJ;IAE3CD,aAAaM,OAAO,CAAC,CAACC;QACpB,IAAIA,OAAOb,QAAQ,OAAOa,MAAMb,IAAI,KAAK,YAAY,YAAYa,MAAMb,IAAI,EAAE;YAC3E,MAAMA,OAAOa,MAAMb,IAAI;YACvB,IAAIA,KAAKG,MAAM,IAAIF,MAAMC,OAAO,CAACF,KAAKG,MAAM,KAAKH,KAAKG,MAAM,CAACC,MAAM,GAAG,GAAG;gBACvEI,UAAUM,IAAI,IAAId,KAAKG,MAAM;gBAC7B,IAAI,CAACM,aAAaT,KAAKS,SAAS,EAAE;oBAChCA,YAAYT,KAAKS,SAAS;gBAC5B;gBACA,IAAI,CAACC,UAAUV,KAAKU,MAAM,EAAE;oBAC1BA,SAASV,KAAKU,MAAM;gBACtB;gBACA,IAAI,CAACC,YAAYX,KAAKW,QAAQ,EAAE;oBAC9BA,WAAWX,KAAKW,QAAQ;gBAC1B;YACF;QACF;IACF;IAEA,IAAIH,UAAUJ,MAAM,GAAG,GAAG;QACxB,OAAO;YACLD,QAAQK;YACRC;YACAC;YACAC;QACF;IACF;IAEA,OAAOJ;AACT,EAAE;AAEF,OAAO,MAAMQ,mBAAmB,CAACZ,QAAoBa;IACnD,MAAMC,YAAYd;IAQlB,IAAIe,aAAaf,OAAOgB,aAAa,IAAIhB,OAAOiB,IAAI;IAEpD,IAAI,CAACF,cAAcA,eAAe,CAAC,OAAO,EAAEF,cAAc,GAAG,EAAE;QAC7DE,aAAaD,UAAUC,UAAU,IAAID,UAAUI,WAAW,IAAIJ,UAAUK,MAAM,IAAInB,OAAOiB,IAAI,IAAI;IACnG;IAEA,IAAI,AAAC,CAAA,CAACF,cAAcA,eAAef,OAAOiB,IAAI,AAAD,KAAMjB,OAAOoB,MAAM,EAAE;QAChE,MAAMA,SAASpB,OAAOoB,MAAM;QAC5B,MAAMC,gBAAgB;YAAE,GAAGD,MAAM;QAAC;QAClC,MAAME,aAAaD,cAAcE,QAAQ;QACzC,OAAOF,cAAcE,QAAQ;QAE7B,MAAMC,aAAaC,OAAOC,OAAO,CAACL,eAC/BM,MAAM,CAAC,CAAC,CAACC,MAAM,GAAKA,UAAUxB,aAAawB,UAAU,QAAQA,UAAU,IACvEC,GAAG,CAAC,CAAC,CAACC,KAAKF,MAAM,GAAK,GAAGE,IAAI,EAAE,EAAEF,MAAM,CAAC,CAAC,EACzCG,IAAI,CAAC;QAER,IAAIT,cAAcE,YAAY;YAC5BT,aAAa,GAAGO,WAAW,CAAC,EAAEE,WAAW,CAAC,CAAC;QAC7C,OAAO,IAAIF,YAAY;YACrBP,aAAaO;QACf,OAAO,IAAIE,YAAY;YACrBT,aAAa,CAAC,CAAC,EAAES,WAAW,CAAC,CAAC;QAChC,OAAO;YACLT,aAAaK,OAAOY,GAAG,IAAIZ,OAAOa,QAAQ,IAAIb,OAAOc,MAAM,IAAI,CAAC,OAAO,EAAErB,cAAc,GAAG;QAC5F;IACF;IAEA,IAAI,CAACE,cAAcA,WAAWoB,IAAI,OAAO,IAAI;QAC3CpB,aAAa,CAAC,OAAO,EAAEF,cAAc,GAAG;IAC1C;IAEA,OAAOE;AACT,EAAE;AAEF,OAAO,MAAMqB,qBAAqB,CAACnB;IACjC,OAAOA,KACJoB,OAAO,CAAC,aAAa,KACrBA,OAAO,CAAC,QAAQ,KAChBA,OAAO,CAAC,OAAO,KACfA,OAAO,CAAC,UAAU,IAClBC,SAAS,CAAC,GAAG;AAClB,EAAE;AAEF,OAAO,MAAMC,mBAAmB,CAACC;IAC/B,OAAOA,SACJH,OAAO,CAAC,iBAAiB,KACzBF,IAAI,GACJM,KAAK,CAAC,OACNd,MAAM,CAAC,CAACe,OAASA,KAAKzC,MAAM,GAAG,GAC/B4B,GAAG,CAAC,CAACa,MAAMC;QACV,IAAIA,UAAU,GAAG;YACf,OAAOD,KAAKE,WAAW;QACzB;QACA,OAAOF,KAAKG,MAAM,CAAC,GAAGC,WAAW,KAAKJ,KAAKK,KAAK,CAAC,GAAGH,WAAW;IACjE,GACCb,IAAI,CAAC;AACV,EAAE;AAEF,OAAO,MAAMiB,qBAAqB,CAACC;IACjC,IAAIC;IAEJ,IAAI,OAAOD,cAAc,UAAU;QACjC,MAAME,OAAO,IAAIC,KAAKH;QACtB,IAAII,MAAMF,KAAKG,OAAO,KAAK;YACzB,OAAOL;QACT;QACAC,cAAcC,KAAKG,OAAO;IAC5B,OAAO;QACLJ,cAAcD,YAAY,OAAOA,YAAYA,YAAY;IAC3D;IAEA,MAAME,OAAO,IAAIC,KAAKF;IACtB,IAAIG,MAAMF,KAAKG,OAAO,KAAK;QACzB,OAAO,IAAIF,KAAKF,aAAaK,WAAW;IAC1C;IAEA,OAAOJ,KAAKI,WAAW;AACzB,EAAE;AAEF,OAAO,MAAMC,iBAAiB,CAAC5B;IAC7B,IAAIA,UAAU,QAAQA,UAAUxB,WAAW;QACzC,OAAO;IACT;IAEA,MAAMqD,cAAcC,OAAO9B;IAE3B,IACE6B,YAAYE,QAAQ,CAAC,QACrBF,YAAYE,QAAQ,CAAC,QACrBF,YAAYE,QAAQ,CAAC,SACrBF,YAAYE,QAAQ,CAAC,OACrB;QACA,OAAO,CAAC,CAAC,EAAEF,YAAYpB,OAAO,CAAC,MAAM,MAAM,CAAC,CAAC;IAC/C;IAEA,OAAOoB;AACT,EAAE;AAMF,OAAO,MAAMG,kBAAkB,CAAC,EAAE/D,IAAI,EAAqB;IACzD,IAAI,CAACD,iBAAiBC,OAAO;QAC3BgE,QAAQC,IAAI,CAAC;QACb,OAAO,IAAIC,KAAK;YAAC;SAAG,EAAE;YAAEC,MAAM;QAAyB;IACzD;IAEA,IAAIC,YAAY;IAChB,MAAMC,SAAkD,CAAC;IACzD,MAAMC,aAAsF,EAAE;IAC9F,IAAIC,mBAAmB;IAEvB,IAAK,IAAIC,IAAI,GAAGA,IAAIxE,KAAKG,MAAM,CAACC,MAAM,EAAEoE,IAAK;QAC3C,MAAMrE,SAASH,KAAKG,MAAM,CAACqE,EAAE;QAE7B,IAAI,CAACrE,QAAQ;YACX;QACF;QAEA,IAAI,CAACF,MAAMC,OAAO,CAACC,OAAOsE,MAAM,KAAKtE,OAAOsE,MAAM,CAACrE,MAAM,KAAK,GAAG;YAC/D;QACF;QAEA,MAAMc,aAAaH,iBAAiBZ,QAAQqE;QAC5C,MAAME,aAAanC,mBAAmBrB;QAEtC,MAAMyD,oBAAoB;YACxBzD;YACAwD,YAAYA,cAAc,CAAC,OAAO,EAAEF,IAAI,GAAG;YAC3CI,cAAczE,OAAOiB,IAAI,IAAI;QAC/B;QAEAkD,WAAWxD,IAAI,CAAC6D;QAChBJ;QAEA,IAAK,IAAIM,IAAI,GAAGA,IAAI1E,OAAOsE,MAAM,CAACrE,MAAM,EAAEyE,IAAK;YAC7C,MAAMC,QAAQ3E,OAAOsE,MAAM,CAACI,EAAE;YAE9B,IAAIzB;YACJ,IAAIrB;YAEJ,IAAI9B,MAAMC,OAAO,CAAC4E,UAAUA,MAAM1E,MAAM,IAAI,GAAG;gBAC7CgD,YAAY0B,KAAK,CAAC,EAAE;gBACpB/C,QAAQ+C,KAAK,CAAC,EAAE;YAClB,OAAO,IAAI,OAAOA,UAAU,YAAYA,UAAU,QAAQ,eAAeA,SAAS,WAAWA,OAAO;gBAClG,MAAMC,YAAYD;gBAClB1B,YAAY2B,UAAU3B,SAAS;gBAC/BrB,QAAQgD,UAAUhD,KAAK;YACzB,OAAO;gBACL;YACF;YAEA,IAAIA,UAAU,QAAQA,UAAUxB,WAAW;gBACzC;YACF;YAEA,MAAMyE,WAAW7B,mBAAmBC;YAEpC,IAAI,CAACiB,MAAM,CAACW,SAAS,EAAE;gBACrBX,MAAM,CAACW,SAAS,GAAG,CAAC;YACtB;YAEAX,MAAM,CAACW,SAAS,CAACL,kBAAkBD,UAAU,CAAC,GAAG3C;QACnD;IACF;IAEA,IAAIwC,qBAAqB,KAAKD,WAAWlE,MAAM,KAAK,GAAG;QACrD4D,QAAQC,IAAI,CAAC;QACb,OAAO,IAAIC,KAAK;YAAC;SAAG,EAAE;YAAEC,MAAM;QAAyB;IACzD;IAEA,MAAMc,iBAAiBrD,OAAOsD,IAAI,CAACb,QAAQjE,MAAM;IACjD,IAAI6E,mBAAmB,GAAG;QACxBjB,QAAQC,IAAI,CAAC;QACb,OAAO,IAAIC,KAAK;YAAC;SAAG,EAAE;YAAEC,MAAM;QAAyB;IACzD;IAEA,MAAMgB,cAAcb,WAAWtC,GAAG,CAAC,CAACoD,OAASA,KAAKV,UAAU;IAC5DN,aAAa,CAAC,SAAS,EAAEe,YAAYjD,IAAI,CAAC,KAAK,EAAE,CAAC;IAElD,MAAMmD,kBAAkBzD,OAAOsD,IAAI,CAACb,QAAQiB,IAAI,CAAC,CAACC,GAAGC;QACnD,MAAMC,QAAQ,IAAIlC,KAAKgC,GAAG9B,OAAO;QACjC,MAAMiC,QAAQ,IAAInC,KAAKiC,GAAG/B,OAAO;QACjC,OAAOgC,QAAQC;IACjB;IAEA,KAAK,MAAMV,YAAYK,gBAAiB;QACtC,MAAMM,UAAUtB,MAAM,CAACW,SAAS;QAChC,MAAMP,SAAmB,EAAE;QAE3B,IAAIkB,SAAS;YACX,KAAK,MAAMjB,cAAcS,YAAa;gBACpC,MAAMpD,QAAQ4D,OAAO,CAACjB,WAAW;gBACjCD,OAAO3D,IAAI,CAAC6C,eAAe5B;YAC7B;YAEAqC,aAAa,GAAGT,eAAeqB,UAAU,CAAC,EAAEP,OAAOvC,IAAI,CAAC,KAAK,EAAE,CAAC;QAClE;IACF;IAEA,OAAO,IAAIgC,KAAK;QAACE;KAAU,EAAE;QAAED,MAAM;IAAyB;AAChE,EAAE"}